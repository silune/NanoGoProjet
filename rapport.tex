\documentclass[11pt,a4paper]{article}
\usepackage[french]{babel}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{verbatim}
\usepackage[margin=1.2in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{proof}

\newcommand{\dd}{\text{d}•}

\pagenumbering{arabic}

\begin{document}


\begin{titlepage}

\vspace{1cm}

	\begin{center}

    \huge{\textbf{Projet Programation 1 : NanoGo}}

		\vspace{5mm} %espace vertical de 5mm

		\begin{large}

		Projet Prog 1

		\vspace{5mm}

		Simon Corbard

		\end{large}

	\end{center}

\vfill

\tableofcontents

\end{titlepage}

\section{Typage}

Le typage s'effectue par un simple parcours de l'arbre, lorsqu'on rencontre une variable l'expression assingée (ou les annotations de type) permet de l'ajouter à l'environnement typée. Pour l'ensemble des expressions on suit les règles de typages grâce à des appels récursifs.

\subsection{Types}

Les types avant typage (\verb|ptype|) sont transformé récursivement en type : \\
 - les types \verb|bool|, \verb|int| et \verb|string| sont connus \\
 - les types pointeurs sont appelés récursivement \\
 - les types structures sont recherchés dans l'environnement de structure et traité en conséquence (ce test est réalisé en premier pour prevenir la situation d'une redefinition d'un type connu)

Les types \verb|Tmany [ ... ]| permettent de désigner le type d'un appel de fonctions ou plus généralement d'une liste d'expression.

Le type \verb|Twild| permet de désigner un type abstrait quelconque (par exemple les expressions \verb|nil| ou \verb|"_"|)

Les égalitées de types sont de également gérée récursivement. Un cas spécial est réservé aux types de la forme \verb|Tmany[typ]| qui sont, dans l'ensemble de mon projet, assimilées au type \verb|typ| simple. Ceci nécéssite de gérer ces cas particulier régulièrement mais simplifie le typage des fonctions.

\subsection{Environnements et variables}

Ici on compte trois structures d'environnement différents : des \verb|Hashtabl| de \verb|String| pour les fonctions et les structures, une \verb|Map.Make(String)| pour les variables. Cette dèrnière structure, plus locale, est plus simple à utiliser lorsqu'il s'agit de gérer la portée des variables.

Avant d'ajouter un élément à l'un de ces environnements on vérifie toujours s'il n'y est pas déjà.

Le cas des variables est particulier : on a besoin d'autoriser l'initialisation de deux variables de même nom dans des blocs distincts. Pour cela je dispose d'une variable globale \verb|depth| qui est incrémenté lors du parcours d'un sous bloc et décrémenté lors de sa sortie. Ainsi avant d'ajouter une variable à un environnement, je vérifie s'il en existe déjà une dans celui ci, et à cette profondeur.

Le nom de variable \verb|"_"| est toujours considéré présent dans l'environnement, de type \verb|Twild|, il ne peut pas y être ajouté (et sera ignorer à la compilation).

\subsection{Left-values}

Dans l'idée de suivre le plus fidèlement possible les règles de typages, le typage des left-values est traité par une fonction auxiliaire. Cette fonction et celle qui type l'arbre syntaxique principal s'appellent mutuellement en suivant les règles de typages.

\section{Compilation}

La compilation parcours l'arbre syntaxique typée et retourne un fichier \verb|.s| en \verb|x86-64|.

\subsection{Expressions arithmétiques}

Pour la compilation des expressions arithmétiques on compile recursivement le terme de gauche. Son retour est stocké dans le registre \verb|%rdi| qui est mis sur la pile le temps de compiler le terme de droite (cf \verb|arith-order.go| pour le test de l'ordre d'execution). Finalement on dépile le premier résultat dans \verb|%rsi| et le résultat de l'opération adéquate est mis dans \verb|%rdi|.
Note spéciale pour la fonction \verb|idivq|, il est nécéssaire d'appeler \verb|cqto| pour effectuer la bonne division.

\subsection{Booléen}

Pour les expressions bouléennes on peut proposer une sémantique simple, semblable à celle de C.
\subsubsection{Operation}
\vspace{-2em}

$$\infer{\rho, \mu \vdash e_1 \; \text{\texttt{\&\&}} \; e_2 \Rightarrow 0, \mu '}{\rho, \mu \vdash e_1 \Rightarrow n_1, \mu ' & n_1 = 0}
\; \text{\; \; \;} \;
\infer{\rho, \mu \vdash e_1 \; \text{\texttt{\&\&}} \; e_2 \Rightarrow n_2, \mu ''}{\rho, \mu \vdash e_1 \Rightarrow n_1, \mu ' & \rho, \mu ' \vdash e_2 \Rightarrow n_2, \mu '' & n_1 \neq 0}$$
$$\infer{\rho, \mu \vdash e_1 \; \text{\texttt{||}} \; e_2 \Rightarrow 1, \mu '}{\rho, \mu \vdash e_1 \Rightarrow n_1, \mu ' & n_1 \neq 0}
\; \text{\; \; \;} \;
\infer{\rho, \mu \vdash e_1 \; \text{\texttt{||}} \; e_2 \Rightarrow n_2, \mu ''}{\rho, \mu \vdash e_1 \Rightarrow n_1, \mu ' & \rho, \mu ' \vdash e_2 \Rightarrow n_2, \mu '' & n_1 = 0}$$
$$\infer{\rho, \mu \vdash \text{\texttt{!}} e_1 \Rightarrow 0, \mu '}{\rho, \mu \vdash e_1 \Rightarrow n_1, \mu ' & n_1 \neq 0}
\; \text{\; \; \;} \;
\infer{\rho, \mu \vdash \text{\texttt{!}} e_1 \Rightarrow 1, \mu '}{\rho, \mu \vdash e_1 \Rightarrow n_1, \mu ' & n_1 = 0}$$

Les règles pour \verb-&&- et \verb-&&- sont dites "lazy" : l'expression de droite n'est pas évaluée si le résultat de l'expression de gauche suffit, sinon c'est le résultat de droite qui est renvoyé.
En pratique les valeurs booléennes évaluées à \verb|true| sont toujours représentées par un \verb|1| mais on ne vérifie que si la representation est différente de \verb|0|.

\subsubsection{Comparaison}
\vspace{-1em}

$$\infer{\rho, \mu \vdash e_1 \; op \; e_2 \Rightarrow 0, \mu ''}{\rho, \mu \vdash e_1 \Rightarrow n_1, \mu ' & \rho, \mu ' \vdash e_2 \Rightarrow n_2, \mu '' & op \in \{\text{\texttt{<}}, \text{\texttt{<=}}, \text{\texttt{>}}, \text{\texttt{>=}}\} & \lnot (n_1 \; op \; n_2)}$$
$$\infer{\rho, \mu \vdash e_1 \; op \; e_2 \Rightarrow 1, \mu ''}{\rho, \mu \vdash e_1 \Rightarrow n_1, \mu ' & \rho, \mu ' \vdash e_2 \Rightarrow n_2, \mu '' & op \in \{\text{\texttt{<}}, \text{\texttt{<=}}, \text{\texttt{>}}, \text{\texttt{>=}}\} & n_1 \; op \; n_2}$$

Les comparaisons d'entier sont compilées à la manière des expressions arithmétiques, on appel la fonction \verb|cmpq| et on jump, en utilisant le bon flag, vers un label qui met soit \verb|0| soit \verb|1| dans \verb|%rdi|.

\subsubsection{Egalité}

Le cas des opérateurs \verb|==| et \verb|!=| est moins évident puisque il dépend du type des expressions :\\
 - les types entiers, pointeurs et booléens sont testés comme des entiers avec la fonction \verb|cmpq|\\
 - le type string est testé avec la fonction \verb|strcmp@PLT| comme en C, elle renvoie \verb|0| si et seulement si les deux chaines de caractères sont les mêmes, il suffit donc de faire un test à \verb|0| avec le résultat\\
 - les types structures sont testés avec un test "lazy" bit à bit sur l'ensemble des espaces alloués aux deux structures (c.f. implémentation des structures)\\

Une fois ces comparaisons effectuées, il suffit de jump, en utilisant le bon flag, vers un label qui met soit \verb|0| soit \verb|1| dans \verb|%rdi|.

\end{document}
